# 如何防止重复发送 Ajax 请求

不推荐用外部变量锁定或修改按钮状态的方式，因为那样比较难：
- 要考虑并理解 success, complete, error, timeout 这些事件的区别，并注册正确的事件，一旦失误，功能将不再可用；
- 不可避免地比普通流程要要多注册一个 complete 事件；
- 恢复状态的代码很容易和不相干的代码混合在一起；

我推荐用主动查询状态的方式（A、B，jQuery 为例）或工具函数的方式（C、D）来去除重复操作，并提供一些例子作为参考：

## A. 独占型提交

只允许同时存在一次提交操作，并且直到本次提交完成才能进行下一次提交。

```js
module.submit = function() {
  if (this.promise_.state() === 'pending') {
    return
  }
  return this.promise_ = $.post('/api/save')
}
```

## B. 贪婪型提交

无限制的提交，但是以最后一次操作为准；亦即需要尽快给出最后一次操作的反馈，而前面的操作结果并不重要。

```js
module.submit = function() {
  if (this.promise_.state() === 'pending') {
    this.promise_.abort()
  }
  // todo
}
```

## C. 节制型提交

无论提交如何频繁，任意两次有效提交的间隔时间必定会大于或等于某一时间间隔；即以一定频率提交。


```js
module.submit = throttle(150, function() {
  // todo
})
```

如果客户发送每隔100毫秒发送过来10次请求，此模块将只接收其中6个（每个在时间线上距离为150毫秒）进行处理。这也是解决查询冲突的一种可选手段，比如以知乎草稿举例，仔细观察可以发现：编辑器的 blur 事件会立即触发保存；保存按钮的 click 事件也会立即触发保存；但是存在一种情况会使这两个事件在数毫秒内连续发生——当焦点在编辑器内部，并且直接去点击保存按钮——这时用 throttle 来处理是可行的。另外还有一些事件处理会很频繁地使用 throttle，如： resize、scroll、mousemove。

## D. 懒惰型提交

任意两次提交的间隔时间，必须大于一个指定时间，才会促成有效提交；即不给休息不干活。

```js
module.submit = debounce(150, function() {
  // todo
})
```

还是以知乎草稿举例，当在编辑器内按下 ctrl + s 时，可以手动保存草稿；如果你连按，程序会表示不理解为什么你要连按，只有等你放弃连按，它才会继续。

## 其他经验

1.所有的Ajax请求都是异步的,我的封装中做一个100毫秒的setTimeout延时.这样就可以有效的解决用户快速重复点击的问题.　足够快的时候,前一请求并没有真正的发出来.就被clearTimeout清除掉了. abort掉Ajax的请求也会有服务端响应,需要消耗资源.

2.如果用户的操作不并足够快.比如点了保存按钮,在服务器没有返回成功的时候,再次点了保存按钮.(事实上两次请求是一样的.而我们更希望第一次的请求是有效的,第二次的可以不做处理).在封装中,我们检查传入ajax的请url及参数是否一致,如果一致.则第二次的AJAX并不发出.

3.最后一种情况,两次相间的请求是不同的请求,比如楼上说快速切换Tab的例子.无法,只能abort掉前一个Ajax请求了.

See Also:

[怎样防止重复发送 Ajax 请求？](https://www.zhihu.com/question/19805411)  

